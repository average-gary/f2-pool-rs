/*
 * F2 Pool API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;

use crate::{apis::ResponseContent, models};
use super::{Error, configuration};

/// struct for passing parameters to the method [`v2_assets_balance_post`]
#[derive(Clone, Debug)]
pub struct V2AssetsBalancePostParams {
    pub v2_assets_balance_post_request: models::V2AssetsBalancePostRequest
}

/// struct for passing parameters to the method [`v2_assets_settle_mode_switch_post`]
#[derive(Clone, Debug)]
pub struct V2AssetsSettleModeSwitchPostParams {
    pub v2_assets_settle_mode_switch_post_request: models::V2AssetsSettleModeSwitchPostRequest
}

/// struct for passing parameters to the method [`v2_assets_transactions_list_post`]
#[derive(Clone, Debug)]
pub struct V2AssetsTransactionsListPostParams {
    pub v2_assets_transactions_list_post_request: models::V2AssetsTransactionsListPostRequest
}

/// struct for passing parameters to the method [`v2_blocks_date_range_post`]
#[derive(Clone, Debug)]
pub struct V2BlocksDateRangePostParams {
    pub v2_blocks_date_range_post_request: models::V2BlocksDateRangePostRequest
}

/// struct for passing parameters to the method [`v2_blocks_paging_post`]
#[derive(Clone, Debug)]
pub struct V2BlocksPagingPostParams {
    pub v2_blocks_paging_post_request: models::V2BlocksPagingPostRequest
}

/// struct for passing parameters to the method [`v2_hash_rate_distribute_post`]
#[derive(Clone, Debug)]
pub struct V2HashRateDistributePostParams {
    pub v2_hash_rate_distribution_info_post_request: models::V2HashRateDistributionInfoPostRequest
}

/// struct for passing parameters to the method [`v2_hash_rate_distribution_info_post`]
#[derive(Clone, Debug)]
pub struct V2HashRateDistributionInfoPostParams {
    pub v2_hash_rate_distribution_info_post_request: models::V2HashRateDistributionInfoPostRequest
}

/// struct for passing parameters to the method [`v2_hash_rate_distribution_orders_post`]
#[derive(Clone, Debug)]
pub struct V2HashRateDistributionOrdersPostParams {
    pub v2_hash_rate_distribution_orders_post_request: models::V2HashRateDistributionOrdersPostRequest
}

/// struct for passing parameters to the method [`v2_hash_rate_distribution_settlements_post`]
#[derive(Clone, Debug)]
pub struct V2HashRateDistributionSettlementsPostParams {
    pub v2_hash_rate_distribution_orders_post_request: models::V2HashRateDistributionOrdersPostRequest
}

/// struct for passing parameters to the method [`v2_hash_rate_distribution_terminate_post`]
#[derive(Clone, Debug)]
pub struct V2HashRateDistributionTerminatePostParams {
    pub v2_hash_rate_distribution_terminate_post_request: models::V2HashRateDistributionTerminatePostRequest
}

/// struct for passing parameters to the method [`v2_hash_rate_history_post`]
#[derive(Clone, Debug)]
pub struct V2HashRateHistoryPostParams {
    pub v2_hash_rate_history_post_request: models::V2HashRateHistoryPostRequest
}

/// struct for passing parameters to the method [`v2_hash_rate_info_list_post`]
#[derive(Clone, Debug)]
pub struct V2HashRateInfoListPostParams {
    pub v2_hash_rate_info_list_post_request: models::V2HashRateInfoListPostRequest
}

/// struct for passing parameters to the method [`v2_hash_rate_info_post`]
#[derive(Clone, Debug)]
pub struct V2HashRateInfoPostParams {
    pub v2_hash_rate_info_post_request: models::V2HashRateInfoPostRequest
}

/// struct for passing parameters to the method [`v2_hash_rate_worker_history_post`]
#[derive(Clone, Debug)]
pub struct V2HashRateWorkerHistoryPostParams {
    pub v2_hash_rate_worker_history_post_request: models::V2HashRateWorkerHistoryPostRequest
}

/// struct for passing parameters to the method [`v2_hash_rate_worker_list_post`]
#[derive(Clone, Debug)]
pub struct V2HashRateWorkerListPostParams {
    pub v2_hash_rate_info_post_request: models::V2HashRateInfoPostRequest
}

/// struct for passing parameters to the method [`v2_mining_user_add_post`]
#[derive(Clone, Debug)]
pub struct V2MiningUserAddPostParams {
    pub v2_mining_user_add_post_request: models::V2MiningUserAddPostRequest
}

/// struct for passing parameters to the method [`v2_mining_user_balance_withdraw_post`]
#[derive(Clone, Debug)]
pub struct V2MiningUserBalanceWithdrawPostParams {
    pub v2_mining_user_balance_withdraw_post_request: models::V2MiningUserBalanceWithdrawPostRequest
}

/// struct for passing parameters to the method [`v2_mining_user_get_post`]
#[derive(Clone, Debug)]
pub struct V2MiningUserGetPostParams {
    pub v2_mining_user_get_post_request: models::V2MiningUserGetPostRequest
}

/// struct for passing parameters to the method [`v2_mining_user_payment_pause_post`]
#[derive(Clone, Debug)]
pub struct V2MiningUserPaymentPausePostParams {
    pub v2_mining_user_payment_pause_post_request: models::V2MiningUserPaymentPausePostRequest
}

/// struct for passing parameters to the method [`v2_mining_user_payment_resume_post`]
#[derive(Clone, Debug)]
pub struct V2MiningUserPaymentResumePostParams {
    pub v2_mining_user_payment_pause_post_request: models::V2MiningUserPaymentPausePostRequest
}

/// struct for passing parameters to the method [`v2_mining_user_read_only_page_add_post`]
#[derive(Clone, Debug)]
pub struct V2MiningUserReadOnlyPageAddPostParams {
    pub v2_mining_user_read_only_page_add_post_request: models::V2MiningUserReadOnlyPageAddPostRequest
}

/// struct for passing parameters to the method [`v2_mining_user_read_only_page_delete_post`]
#[derive(Clone, Debug)]
pub struct V2MiningUserReadOnlyPageDeletePostParams {
    pub v2_mining_user_read_only_page_delete_post_request: models::V2MiningUserReadOnlyPageDeletePostRequest
}

/// struct for passing parameters to the method [`v2_mining_user_threshold_update_post`]
#[derive(Clone, Debug)]
pub struct V2MiningUserThresholdUpdatePostParams {
    pub v2_mining_user_threshold_update_post_request: models::V2MiningUserThresholdUpdatePostRequest
}

/// struct for passing parameters to the method [`v2_mining_user_wallet_update_post`]
#[derive(Clone, Debug)]
pub struct V2MiningUserWalletUpdatePostParams {
    pub v2_mining_user_wallet_update_post_request: models::V2MiningUserWalletUpdatePostRequest
}

/// struct for passing parameters to the method [`v2_revenue_distribution_add_post`]
#[derive(Clone, Debug)]
pub struct V2RevenueDistributionAddPostParams {
    pub v2_revenue_distribution_add_post_request: models::V2RevenueDistributionAddPostRequest
}

/// struct for passing parameters to the method [`v2_revenue_distribution_delete_post`]
#[derive(Clone, Debug)]
pub struct V2RevenueDistributionDeletePostParams {
    pub v2_revenue_distribution_delete_post_request: models::V2RevenueDistributionDeletePostRequest
}

/// struct for passing parameters to the method [`v2_revenue_distribution_info_post`]
#[derive(Clone, Debug)]
pub struct V2RevenueDistributionInfoPostParams {
    pub v2_revenue_distribution_info_post_request: models::V2RevenueDistributionInfoPostRequest
}


/// struct for typed errors of method [`v2_assets_balance_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum V2AssetsBalancePostError {
    DefaultResponse(models::V2MiningUserListPostDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`v2_assets_settle_mode_switch_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum V2AssetsSettleModeSwitchPostError {
    DefaultResponse(models::V2MiningUserListPostDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`v2_assets_transactions_list_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum V2AssetsTransactionsListPostError {
    DefaultResponse(models::V2MiningUserListPostDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`v2_blocks_date_range_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum V2BlocksDateRangePostError {
    DefaultResponse(models::V2HashRateDistributionInfoPostDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`v2_blocks_paging_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum V2BlocksPagingPostError {
    DefaultResponse(models::V2HashRateDistributionInfoPostDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`v2_hash_rate_distribute_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum V2HashRateDistributePostError {
    DefaultResponse(models::V2HashRateDistributionInfoPostDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`v2_hash_rate_distribution_info_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum V2HashRateDistributionInfoPostError {
    DefaultResponse(models::V2HashRateDistributionInfoPostDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`v2_hash_rate_distribution_orders_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum V2HashRateDistributionOrdersPostError {
    DefaultResponse(models::V2HashRateDistributionInfoPostDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`v2_hash_rate_distribution_settlements_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum V2HashRateDistributionSettlementsPostError {
    DefaultResponse(models::V2HashRateDistributionInfoPostDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`v2_hash_rate_distribution_terminate_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum V2HashRateDistributionTerminatePostError {
    DefaultResponse(models::V2HashRateDistributionInfoPostDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`v2_hash_rate_history_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum V2HashRateHistoryPostError {
    DefaultResponse(models::V2MiningUserListPostDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`v2_hash_rate_info_list_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum V2HashRateInfoListPostError {
    DefaultResponse(models::V2MiningUserListPostDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`v2_hash_rate_info_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum V2HashRateInfoPostError {
    DefaultResponse(models::V2MiningUserListPostDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`v2_hash_rate_worker_history_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum V2HashRateWorkerHistoryPostError {
    DefaultResponse(models::V2MiningUserListPostDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`v2_hash_rate_worker_list_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum V2HashRateWorkerListPostError {
    DefaultResponse(models::V2MiningUserListPostDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`v2_mining_user_add_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum V2MiningUserAddPostError {
    DefaultResponse(models::V2MiningUserGetPostDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`v2_mining_user_balance_withdraw_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum V2MiningUserBalanceWithdrawPostError {
    DefaultResponse(models::V2MiningUserListPostDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`v2_mining_user_get_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum V2MiningUserGetPostError {
    DefaultResponse(models::V2MiningUserGetPostDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`v2_mining_user_list_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum V2MiningUserListPostError {
    DefaultResponse(models::V2MiningUserListPostDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`v2_mining_user_payment_pause_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum V2MiningUserPaymentPausePostError {
    DefaultResponse(models::V2MiningUserListPostDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`v2_mining_user_payment_resume_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum V2MiningUserPaymentResumePostError {
    DefaultResponse(models::V2MiningUserListPostDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`v2_mining_user_read_only_page_add_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum V2MiningUserReadOnlyPageAddPostError {
    DefaultResponse(models::V2MiningUserListPostDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`v2_mining_user_read_only_page_delete_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum V2MiningUserReadOnlyPageDeletePostError {
    DefaultResponse(models::V2MiningUserListPostDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`v2_mining_user_threshold_update_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum V2MiningUserThresholdUpdatePostError {
    DefaultResponse(models::V2MiningUserListPostDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`v2_mining_user_wallet_update_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum V2MiningUserWalletUpdatePostError {
    DefaultResponse(models::V2MiningUserListPostDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`v2_revenue_distribution_add_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum V2RevenueDistributionAddPostError {
    DefaultResponse(models::V2HashRateDistributionInfoPostDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`v2_revenue_distribution_delete_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum V2RevenueDistributionDeletePostError {
    DefaultResponse(models::V2HashRateDistributionInfoPostDefaultResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`v2_revenue_distribution_info_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum V2RevenueDistributionInfoPostError {
    DefaultResponse(models::V2HashRateDistributionInfoPostDefaultResponse),
    UnknownValue(serde_json::Value),
}


pub async fn v2_assets_balance_post(configuration: &configuration::Configuration, params: V2AssetsBalancePostParams) -> Result<models::V2AssetsBalancePost200Response, Error<V2AssetsBalancePostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let v2_assets_balance_post_request = params.v2_assets_balance_post_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/assets/balance", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&v2_assets_balance_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<V2AssetsBalancePostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn v2_assets_settle_mode_switch_post(configuration: &configuration::Configuration, params: V2AssetsSettleModeSwitchPostParams) -> Result<models::V2AssetsSettleModeSwitchPost200Response, Error<V2AssetsSettleModeSwitchPostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let v2_assets_settle_mode_switch_post_request = params.v2_assets_settle_mode_switch_post_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/assets/settle_mode/switch", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&v2_assets_settle_mode_switch_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<V2AssetsSettleModeSwitchPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn v2_assets_transactions_list_post(configuration: &configuration::Configuration, params: V2AssetsTransactionsListPostParams) -> Result<models::V2AssetsTransactionsListPost200Response, Error<V2AssetsTransactionsListPostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let v2_assets_transactions_list_post_request = params.v2_assets_transactions_list_post_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/assets/transactions/list", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&v2_assets_transactions_list_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<V2AssetsTransactionsListPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn v2_blocks_date_range_post(configuration: &configuration::Configuration, params: V2BlocksDateRangePostParams) -> Result<models::V2BlocksPagingPost200Response, Error<V2BlocksDateRangePostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let v2_blocks_date_range_post_request = params.v2_blocks_date_range_post_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/blocks/date_range", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&v2_blocks_date_range_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<V2BlocksDateRangePostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn v2_blocks_paging_post(configuration: &configuration::Configuration, params: V2BlocksPagingPostParams) -> Result<models::V2BlocksPagingPost200Response, Error<V2BlocksPagingPostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let v2_blocks_paging_post_request = params.v2_blocks_paging_post_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/blocks/paging", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&v2_blocks_paging_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<V2BlocksPagingPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn v2_hash_rate_distribute_post(configuration: &configuration::Configuration, params: V2HashRateDistributePostParams) -> Result<models::HashRateDistributionOrder, Error<V2HashRateDistributePostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let v2_hash_rate_distribution_info_post_request = params.v2_hash_rate_distribution_info_post_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/hash_rate/distribute", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&v2_hash_rate_distribution_info_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<V2HashRateDistributePostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn v2_hash_rate_distribution_info_post(configuration: &configuration::Configuration, params: V2HashRateDistributionInfoPostParams) -> Result<models::V2HashRateDistributionInfoPost200Response, Error<V2HashRateDistributionInfoPostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let v2_hash_rate_distribution_info_post_request = params.v2_hash_rate_distribution_info_post_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/hash_rate/distribution/info", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&v2_hash_rate_distribution_info_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<V2HashRateDistributionInfoPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn v2_hash_rate_distribution_orders_post(configuration: &configuration::Configuration, params: V2HashRateDistributionOrdersPostParams) -> Result<models::V2HashRateDistributionOrdersPost200Response, Error<V2HashRateDistributionOrdersPostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let v2_hash_rate_distribution_orders_post_request = params.v2_hash_rate_distribution_orders_post_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/hash_rate/distribution/orders", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&v2_hash_rate_distribution_orders_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<V2HashRateDistributionOrdersPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn v2_hash_rate_distribution_settlements_post(configuration: &configuration::Configuration, params: V2HashRateDistributionSettlementsPostParams) -> Result<models::V2HashRateDistributionSettlementsPost200Response, Error<V2HashRateDistributionSettlementsPostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let v2_hash_rate_distribution_orders_post_request = params.v2_hash_rate_distribution_orders_post_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/hash_rate/distribution/settlements", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&v2_hash_rate_distribution_orders_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<V2HashRateDistributionSettlementsPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn v2_hash_rate_distribution_terminate_post(configuration: &configuration::Configuration, params: V2HashRateDistributionTerminatePostParams) -> Result<models::V2HashRateDistributionTerminatePost200Response, Error<V2HashRateDistributionTerminatePostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let v2_hash_rate_distribution_terminate_post_request = params.v2_hash_rate_distribution_terminate_post_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/hash_rate/distribution/terminate", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&v2_hash_rate_distribution_terminate_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<V2HashRateDistributionTerminatePostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn v2_hash_rate_history_post(configuration: &configuration::Configuration, params: V2HashRateHistoryPostParams) -> Result<models::V2HashRateHistoryPost200Response, Error<V2HashRateHistoryPostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let v2_hash_rate_history_post_request = params.v2_hash_rate_history_post_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/hash_rate/history", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&v2_hash_rate_history_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<V2HashRateHistoryPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn v2_hash_rate_info_list_post(configuration: &configuration::Configuration, params: V2HashRateInfoListPostParams) -> Result<models::V2HashRateInfoListPost200Response, Error<V2HashRateInfoListPostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let v2_hash_rate_info_list_post_request = params.v2_hash_rate_info_list_post_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/hash_rate/info_list", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&v2_hash_rate_info_list_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<V2HashRateInfoListPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn v2_hash_rate_info_post(configuration: &configuration::Configuration, params: V2HashRateInfoPostParams) -> Result<models::V2HashRateInfoPost200Response, Error<V2HashRateInfoPostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let v2_hash_rate_info_post_request = params.v2_hash_rate_info_post_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/hash_rate/info", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&v2_hash_rate_info_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<V2HashRateInfoPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn v2_hash_rate_worker_history_post(configuration: &configuration::Configuration, params: V2HashRateWorkerHistoryPostParams) -> Result<models::V2HashRateHistoryPost200Response, Error<V2HashRateWorkerHistoryPostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let v2_hash_rate_worker_history_post_request = params.v2_hash_rate_worker_history_post_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/hash_rate/worker/history", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&v2_hash_rate_worker_history_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<V2HashRateWorkerHistoryPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn v2_hash_rate_worker_list_post(configuration: &configuration::Configuration, params: V2HashRateWorkerListPostParams) -> Result<models::V2HashRateWorkerListPost200Response, Error<V2HashRateWorkerListPostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let v2_hash_rate_info_post_request = params.v2_hash_rate_info_post_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/hash_rate/worker/list", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&v2_hash_rate_info_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<V2HashRateWorkerListPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn v2_mining_user_add_post(configuration: &configuration::Configuration, params: V2MiningUserAddPostParams) -> Result<models::V2MiningUserAddPost200Response, Error<V2MiningUserAddPostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let v2_mining_user_add_post_request = params.v2_mining_user_add_post_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/mining_user/add", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&v2_mining_user_add_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<V2MiningUserAddPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn v2_mining_user_balance_withdraw_post(configuration: &configuration::Configuration, params: V2MiningUserBalanceWithdrawPostParams) -> Result<models::V2MiningUserBalanceWithdrawPost200Response, Error<V2MiningUserBalanceWithdrawPostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let v2_mining_user_balance_withdraw_post_request = params.v2_mining_user_balance_withdraw_post_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/mining_user/balance/withdraw", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&v2_mining_user_balance_withdraw_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<V2MiningUserBalanceWithdrawPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn v2_mining_user_get_post(configuration: &configuration::Configuration, params: V2MiningUserGetPostParams) -> Result<models::V2MiningUserGetPost200Response, Error<V2MiningUserGetPostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let v2_mining_user_get_post_request = params.v2_mining_user_get_post_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/mining_user/get", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&v2_mining_user_get_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<V2MiningUserGetPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn v2_mining_user_list_post(configuration: &configuration::Configuration) -> Result<models::V2MiningUserListPost200Response, Error<V2MiningUserListPostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/mining_user/list", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<V2MiningUserListPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn v2_mining_user_payment_pause_post(configuration: &configuration::Configuration, params: V2MiningUserPaymentPausePostParams) -> Result<models::V2MiningUserWalletUpdatePost200Response, Error<V2MiningUserPaymentPausePostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let v2_mining_user_payment_pause_post_request = params.v2_mining_user_payment_pause_post_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/mining_user/payment/pause", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&v2_mining_user_payment_pause_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<V2MiningUserPaymentPausePostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn v2_mining_user_payment_resume_post(configuration: &configuration::Configuration, params: V2MiningUserPaymentResumePostParams) -> Result<models::V2MiningUserWalletUpdatePost200Response, Error<V2MiningUserPaymentResumePostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let v2_mining_user_payment_pause_post_request = params.v2_mining_user_payment_pause_post_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/mining_user/payment/resume", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&v2_mining_user_payment_pause_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<V2MiningUserPaymentResumePostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn v2_mining_user_read_only_page_add_post(configuration: &configuration::Configuration, params: V2MiningUserReadOnlyPageAddPostParams) -> Result<models::V2MiningUserReadOnlyPageAddPost200Response, Error<V2MiningUserReadOnlyPageAddPostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let v2_mining_user_read_only_page_add_post_request = params.v2_mining_user_read_only_page_add_post_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/mining_user/read_only_page/add", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&v2_mining_user_read_only_page_add_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<V2MiningUserReadOnlyPageAddPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn v2_mining_user_read_only_page_delete_post(configuration: &configuration::Configuration, params: V2MiningUserReadOnlyPageDeletePostParams) -> Result<models::V2MiningUserGetPostRequest, Error<V2MiningUserReadOnlyPageDeletePostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let v2_mining_user_read_only_page_delete_post_request = params.v2_mining_user_read_only_page_delete_post_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/mining_user/read_only_page/delete", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&v2_mining_user_read_only_page_delete_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<V2MiningUserReadOnlyPageDeletePostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn v2_mining_user_threshold_update_post(configuration: &configuration::Configuration, params: V2MiningUserThresholdUpdatePostParams) -> Result<models::V2MiningUserThresholdUpdatePost200Response, Error<V2MiningUserThresholdUpdatePostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let v2_mining_user_threshold_update_post_request = params.v2_mining_user_threshold_update_post_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/mining_user/threshold/update", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&v2_mining_user_threshold_update_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<V2MiningUserThresholdUpdatePostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn v2_mining_user_wallet_update_post(configuration: &configuration::Configuration, params: V2MiningUserWalletUpdatePostParams) -> Result<models::V2MiningUserWalletUpdatePost200Response, Error<V2MiningUserWalletUpdatePostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let v2_mining_user_wallet_update_post_request = params.v2_mining_user_wallet_update_post_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/mining_user/wallet/update", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&v2_mining_user_wallet_update_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<V2MiningUserWalletUpdatePostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn v2_revenue_distribution_add_post(configuration: &configuration::Configuration, params: V2RevenueDistributionAddPostParams) -> Result<models::V2RevenueDistributionAddPost200Response, Error<V2RevenueDistributionAddPostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let v2_revenue_distribution_add_post_request = params.v2_revenue_distribution_add_post_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/revenue/distribution/add", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&v2_revenue_distribution_add_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<V2RevenueDistributionAddPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn v2_revenue_distribution_delete_post(configuration: &configuration::Configuration, params: V2RevenueDistributionDeletePostParams) -> Result<models::V2HashRateDistributionTerminatePost200Response, Error<V2RevenueDistributionDeletePostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let v2_revenue_distribution_delete_post_request = params.v2_revenue_distribution_delete_post_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/revenue/distribution/delete", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&v2_revenue_distribution_delete_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<V2RevenueDistributionDeletePostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

pub async fn v2_revenue_distribution_info_post(configuration: &configuration::Configuration, params: V2RevenueDistributionInfoPostParams) -> Result<models::V2RevenueDistributionInfoPost200Response, Error<V2RevenueDistributionInfoPostError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let v2_revenue_distribution_info_post_request = params.v2_revenue_distribution_info_post_request;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v2/revenue/distribution/info", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&v2_revenue_distribution_info_post_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<V2RevenueDistributionInfoPostError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

